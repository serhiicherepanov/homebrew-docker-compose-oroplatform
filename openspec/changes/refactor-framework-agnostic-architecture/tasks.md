# Implementation Tasks

## 1. Analysis and Preparation
- [ ] 1.1 Document all existing functions and categorize:
  - Core infrastructure functions
  - Oro-specific functions → move to plugin
  - Framework-agnostic CLI functions
- [ ] 1.2 Design minimal core variable scheme (DC_*)
- [ ] 1.3 Map each existing service to separate compose file:
  - Which services are core (PHP, nginx, DB, Redis, MQ)
  - Which services are framework-specific (Elasticsearch, WebSocket, Consumer)
- [ ] 1.4 Design plugin interface and discovery
- [ ] 1.5 Create test strategy for:
  - Core without plugins
  - Core + Oro plugin
  - Individual service compose files
- [ ] 1.6 Finalize project naming (dcx confirmed)

## 2. Core System Module (Bash)
- [ ] 2.1 Create bin/dcx entry point (~100 lines)
  - Strict mode: set -euo pipefail
  - Module loader
  - Command dispatcher
- [ ] 2.2 Create bin/dcx.d/00-core.sh
  - Docker Compose orchestration functions
  - Compose file loading logic
  - Command execution wrapper
- [ ] 2.3 Add bats test framework setup
  - Install instructions
  - Test directory structure
  - Example tests
- [ ] 2.4 Add shellcheck configuration
  - .shellcheckrc
  - CI/CD integration
  - Local validation script
- [ ] 2.5 Write bats tests for core functions
  - Test compose file loading
  - Test Docker Compose command building
  - Test error handling
- [ ] 2.6 Document bash coding standards
  - Modern bash features to use
  - Error handling patterns
  - Testing approach

## 3. Utilities Module
- [ ] 3.1 Create bin/dcx.d/10-utils.sh
- [ ] 3.2 Extract message formatting functions (msg_info, msg_error, etc.)
- [ ] 3.3 Extract binary resolution functions (resolve_bin)
- [ ] 3.4 Add utility function tests
- [ ] 3.5 Document utility function API

## 4. Environment Module
- [ ] 4.1 Create bin/dcx.d/20-env.sh
- [ ] 4.2 Implement clean environment variable initialization (DC_*)
- [ ] 4.3 Add framework-agnostic defaults
- [ ] 4.4 Extract .env file loading logic (.env.dcx)
- [ ] 4.5 Add environment validation functions
- [ ] 4.6 Add environment resolution tests

## 5. Smart Argument Parsing (CRITICAL - Core UX Feature)
- [ ] 5.1 Create bin/dcx.d/30-argument-parser.sh
  - Parse Docker Compose flags (left vs right)
  - Detect command boundary
  - Organize into buckets (left_flags, command, args, right_flags)
  - Handle --option=value and --option value forms
  - Preserve argument quoting and special chars
- [ ] 5.2 Implement is_compose_command() detection
  - Recognize all Docker Compose native commands
  - up, down, start, stop, restart
  - ps, logs, exec, run, build, pull, push
  - config, version, ls, etc.
- [ ] 5.3 Add argument preservation
  - Proper bash array handling: "${args[@]}"
  - Quote preservation
  - Special character escaping
  - Space handling in arguments
- [ ] 5.4 Write comprehensive tests for argument parsing
  - Test: dcx --profile=test up -d
  - Test: dcx --profile=test run --rm cli php bin/console cache:clear --env=prod
  - Test: Arguments with spaces and quotes
  - Test: Special characters ($, `, !, etc.)
- [ ] 5.5 Add DEBUG mode output
  - Show parsed buckets
  - Show final command
  - Help troubleshoot argument issues
- [ ] 5.6 Performance optimize
  - Skip parsing for simple commands
  - Fast path for common cases
  - Maintain <100ms startup target

## 6. Transparent Binary Redirection (CRITICAL - Core UX Feature)
- [ ] 6.1 Create bin/dcx.d/35-redirect.sh
  - Detect calling name (symlink support)
  - Detect PHP flags (-v, --version, -r, etc.)
  - Detect file extensions (.php, .js, .py)
  - Detect framework patterns (bin/console, cache:*, oro:*)
- [ ] 6.2 Implement detect_transparent_redirect()
  - Check if called as symlink (php, node, python)
  - Check first argument for indicators
  - Return detected binary or false

## 6a. Sync Mode Support
- [ ] 6a.1 Create compose/modes/ directory
  - compose/modes/default.yml (direct volume mount)
  - compose/modes/mutagen.yml (Mutagen sync for macOS)
  - compose/modes/ssh.yml (SSH remote sync)
- [ ] 6a.2 Implement mode selection logic in bin/dcx.d/00-core.sh
  - Read DC_MODE environment variable
  - Validate mode against available modes
  - Load appropriate compose/modes/*.yml file
- [ ] 6a.3 Add Mutagen support
  - Check mutagen binary availability
  - Generate mutagen sync configuration
  - Start/stop mutagen sessions
- [ ] 6a.4 Add SSH mode support
  - SSH key management
  - Remote Docker connection
  - File synchronization
- [ ] 6a.5 Write tests for sync mode selection
  - Test default mode
  - Test mutagen mode (mock binary)
  - Test ssh mode
  - Test invalid mode error

## 6b. Multiple Hostname Support (DC_EXTRA_HOSTS)
- [ ] 6b.1 Implement hostname parsing in bin/dcx.d/20-env.sh
  - Parse DC_EXTRA_HOSTS comma-separated list
  - Trim whitespace from entries
  - Filter empty entries
- [ ] 6b.2 Implement hostname processing
  - Detect short names (single word)
  - Append .docker.local to short names
  - Keep full hostnames as-is
  - Build hostname array
- [ ] 6b.3 Generate Traefik routing rule
  - Combine main hostname + extra hosts
  - Generate Host() || Host() || ... rule
  - Export DC_TRAEFIK_RULE variable
- [ ] 6b.4 Update nginx configuration
  - Generate server_name directive with all hosts
  - Update nginx/site.conf.j2 template
- [ ] 6b.5 Write tests for hostname processing
  - Test short names: "api,admin"
  - Test full names: "api.local,admin.example.com"
  - Test mixed: "api,admin.local,external.com"
  - Test empty/whitespace handling

## 6c. XDEBUG Configuration Support
- [ ] 6c.1 Implement XDEBUG environment detection
  - Read XDEBUG_MODE (global)
  - Read XDEBUG_MODE_FPM, XDEBUG_MODE_CLI, XDEBUG_MODE_CONSUMER
  - Per-container overrides global mode
- [ ] 6c.2 Implement XDEBUG mode persistence
  - Save XDEBUG settings to ${DC_CONFIG_DIR}/.xdebug_env
  - Load saved settings on startup
  - Override with new environment variables if provided
- [ ] 6c.3 Pass XDEBUG configuration to containers
  - Set XDEBUG_MODE environment in PHP containers
  - Different modes for FPM, CLI, consumer
  - Default to "off" if not set
- [ ] 6c.4 Add XDEBUG validation
  - Validate mode values (off, debug, coverage, profile, trace)
  - Show error for invalid modes
  - List supported modes
- [ ] 6c.5 Update compose files for XDEBUG
  - Add XDEBUG_MODE to service environment sections
  - Support per-service overrides
- [ ] 6c.6 Write tests for XDEBUG configuration
  - Test global mode
  - Test per-container modes
  - Test persistence
  - Test validation

## 6d. Custom Docker Image Configuration
- [ ] 6d.1 Define custom image environment variables
  - DC_PGSQL_IMAGE, DC_PGSQL_VERSION
  - DC_MYSQL_IMAGE, DC_MYSQL_VERSION
  - DC_REDIS_IMAGE, DC_REDIS_VERSION
  - DC_NGINX_IMAGE, DC_NGINX_VERSION
  - DC_RABBITMQ_IMAGE, DC_RABBITMQ_VERSION
- [ ] 6d.2 Update compose service files to use variables
  - compose/services/database-pgsql.yml: image: ${DC_PGSQL_IMAGE}:${DC_PGSQL_VERSION}
  - compose/services/database-mysql.yml: image: ${DC_MYSQL_IMAGE}:${DC_MYSQL_VERSION}
  - compose/services/redis.yml: image: ${DC_REDIS_IMAGE}:${DC_REDIS_VERSION}
  - compose/services/nginx.yml: image: ${DC_NGINX_IMAGE}:${DC_NGINX_VERSION}
- [ ] 6d.3 Add custom image defaults
  - Set default images in bin/dcx.d/20-env.sh
  - Allow overrides from .env.dcx
  - Validate image accessibility
- [ ] 6d.4 Write tests for custom images
  - Test custom PostgreSQL image
  - Test custom Redis image
  - Test invalid image handling
- [ ] 6.3 Implement execute_with_redirect()
  - Check if container running (exec vs run)
  - Execute with proper binary
  - Pass all arguments through
  - Preserve stdin/stdout/stderr
- [ ] 6.4 Add DC_DEFAULT_BINARY configuration
  - Environment variable support
  - Plugin can set default
  - Values: php, node, python, ruby, make, none
  - Document per-project configuration
- [ ] 6.5 Test symlink functionality
  - ln -s dcx php
  - Test php --version
  - Test php bin/console
  - Test php script.php
- [ ] 6.6 Test transparent detection
  - dcx -v (PHP version)
  - dcx bin/console cache:clear
  - dcx script.php args
  - dcx node app.js (if DC_DEFAULT_BINARY=node)
- [ ] 6.7 Document transparent redirection
  - How it works
  - Configuration options
  - Framework-specific behavior
  - Troubleshooting

## 7. Pipeline & Command Routing
- [ ] 7.1 Create bin/dcx.d/40-pipeline.sh
  - Integrate argument parser
  - Integrate transparent redirect
  - Command routing logic
  - Error handling
- [ ] 7.2 Implement command dispatcher
  - Route Docker Compose commands
  - Route plugin commands
  - Route transparent redirects
  - Route core commands (ssh, cli, bash)
- [ ] 7.3 Add command execution wrapper
  - Build final docker compose command
  - Execute with proper flags
  - Stream output
  - Capture exit code
- [ ] 7.4 Write integration tests
  - Test full command flow
  - Test all routing paths
  - Test error scenarios

## 6. Compose Management Module
- [ ] 6.1 Create bin/dcx.d/40-compose.sh
- [ ] 6.2 Extract compose file management functions
- [ ] 6.3 Implement profile caching system
- [ ] 6.4 Add DSN parsing functions
- [ ] 6.5 Extract Traefik rule building
- [ ] 6.6 Add Docker network management
- [ ] 6.7 Test compose file merging logic

## 8. Core CLI Commands (Framework-Agnostic)
- [ ] 8.1 Create bin/dcx.d/50-cli.sh (generic CLI commands)
- [ ] 7.2 Implement database commands:
  - dcx psql (PostgreSQL CLI)
  - dcx mysql (MySQL CLI)
  - dcx database-cli (generic DB shell)
- [ ] 7.3 Create bin/dcx.d/40-database.sh (import/export)
- [ ] 7.4 Implement database import:
  - Support .sql and .sql.gz formats
  - Auto-detect database schema
  - Progress reporting
- [ ] 7.5 Implement database export:
  - Auto-detect database schema
  - Compress with gzip
  - Timestamped filenames
  - MySQL DEFINER cleanup
- [ ] 7.6 Implement container commands:
  - dcx ssh (SSH access)
  - dcx cli (CLI container bash)
  - dcx bash (alias for cli)
- [ ] 7.7 Test all CLI commands without plugins
- [ ] 7.8 Document core CLI command usage

## 9. Database Operations Module
- [ ] 9.1 Create bin/dcx.d/60-database.sh
- [ ] 9.2 Implement database import (from tasks 8.4-8.5)
- [ ] 9.3 Implement database export (from tasks 8.4-8.5)
- [ ] 9.4-9.8 (keep existing database tasks)

## 7a. Hybrid JSON Communication Protocol (stdin + ENV)
- [ ] 7a.1 Design hybrid JSON communication protocol
  - Context: JSON via DCX_CONTEXT environment variable (shared, immutable)
  - Input: JSON via stdin (command-specific data)
  - Output: JSON via stdout (command result)
  - Logs: stderr (debug, execution steps, JSON dumps)
- [ ] 7a.2 Define DCX_CONTEXT structure
  - dcx.version, dcx.plugin, dcx.mode
  - paths.project_root, paths.config_dir, paths.compose_dir
  - state.containers_running, state.database_initialized
  - Optional: user info, system info
- [ ] 7a.4 Create JSON helper functions in bin/dcx.d/45-json-helpers.sh
  - log() - log to stderr with timestamp
  - log_json() - pretty-print JSON to stderr with colors
  - read_context() - read and parse DCX_CONTEXT (with defaults)
  - success_result() - generate success JSON
  - error_result() - generate error JSON
  - validate_json() - validate JSON against schema (jq-based)
- [ ] 7a.5 Define standard result JSON format
  - status: "success" | "error"
  - message: human-readable message
  - exit_code: integer (0 for success)
  - data: command-specific result
  - warnings: array of warnings
  - errors: array of errors
  - metadata: optional (duration, timestamp)
- [ ] 7a.4 Create schemas/core/ directory with core schemas
  - command-result.schema.json (standard result format)
  - project-config.schema.json (project configuration)
  - database-config.schema.json (database configuration)
- [ ] 7a.6 Implement jq-based JSON validation function
  - Check JSON syntax validity (jq empty)
  - Extract required fields from schema
  - Validate required fields exist
  - Validate field types match schema
  - No external dependencies (jq only)
- [ ] 7a.7 Create DCX_CONTEXT management in core
  - Build context JSON at dcx startup
  - Export DCX_CONTEXT environment variable
  - Context persists for all commands in session
  - Log context to debug log
- [ ] 7a.8 Write tests for JSON helpers
  - Test success_result() format
  - Test error_result() format
  - Test log_json() output
  - Test validation with valid/invalid JSON

## 7b. Plugin Discovery via JSON Manifest
- [ ] 7b.1 Define plugin.json manifest structure
  - name, version, description, homepage, author
  - detection.priority (0-100)
  - detection.rules[] (array of detection rules)
  - requirements (dcx version, PHP, Node, services)
  - provides (commands, services)
  - config (defaults)
- [ ] 7b.2 Design detection rule types
  - composer_packages: detect by Composer dependencies
  - npm_packages: detect by npm dependencies
  - pip_packages: detect by Python requirements
  - file_exists: detect by file/directory existence
  - directory_structure: detect by directory layout
  - file_content: detect by patterns in files
  - json_field: detect by JSON field values
- [ ] 7b.3 Create plugin manifest examples
  - examples/plugin-oro.json (Oro Platform)
  - examples/plugin-magento.json (Magento 2.x)
  - examples/plugin-laravel.json (Laravel)
- [ ] 7b.4 Implement plugin discovery in bin/dcx.d/48-plugin-discovery.sh
  - discover_plugins() - scan Homebrew formulas dcx-plugin-*
  - Search paths: project/.dcx/plugins, ~/.dcx/plugins, Homebrew, built-in
  - Load and validate plugin.json manifests
  - Return list of valid plugin manifests
- [ ] 7b.5 Implement detection rule validators
  - detect_composer_packages() - check composer.json
  - detect_npm_packages() - check package.json
  - detect_file_exists() - check files exist
  - detect_directory_structure() - verify directory tree
  - detect_file_content() - grep patterns in files
  - detect_json_field() - jq field value check
- [ ] 7b.6 Implement plugin selection logic
  - Run all detection rules for each plugin
  - Combine rules with AND logic (all must pass)
  - Collect matching plugins with priorities
  - Sort by priority (descending)
  - Select highest priority plugin
  - Export DCX_PLUGIN, DCX_PLUGIN_MANIFEST
- [ ] 7b.7 Handle no plugin match
  - Default to "generic" plugin
  - Log warning about no specific framework detected
  - Generic plugin provides basic PHP/Node functionality
- [ ] 7b.8 Support explicit plugin selection
  - Check DCX_PLUGIN environment variable
  - Skip auto-detection if set
  - Load specified plugin directly
  - Error if plugin doesn't exist
- [ ] 7b.9 Create plugin CLI commands
  - dcx plugins list - show all installed plugins
  - dcx plugins info <name> - show plugin details
  - dcx plugins detect - run detection for current project
  - dcx plugins validate <name> - validate plugin manifest
- [ ] 7b.10 Write tests for plugin discovery
  - Test manifest parsing and validation
  - Test each detection rule type
  - Test priority-based selection
  - Test explicit plugin selection
  - Test no-match fallback to generic

## 8. Plugin System (Fixed Structure Convention + JSON)
- [ ] 8.1 Create bin/dcx.d/50-plugin-loader.sh
- [ ] 8.2 Design fixed plugin directory structure convention
  - REQUIRED: README.md, plugin.sh, commands/, services/, schemas/
  - REQUIRED: Each command has directory with run.sh + README.md
  - REQUIRED: All data via JSON stdin/stdout (no arguments, no env vars for data)
  - REQUIRED: Each command has input/output JSON Schema files
- [ ] 8.3 Implement plugin interface (plugin_detect, plugin_init, etc.)
  - plugin_detect() → bool (return 0 if framework detected)
  - plugin_name() → string (return plugin name)
  - plugin_init() → void (auto-register commands from commands/)
  - plugin_compose_files() → array (return service YAML files)
- [ ] 8.4 Implement plugin discovery mechanism
  - Scan plugins/*/ directories
  - Source plugin.sh for each plugin
  - Call plugin_detect() to check if applicable
  - Break on first detected plugin
- [ ] 8.5 Implement command auto-registration from directory structure
  - Scan plugins/{name}/commands/*/ directories
  - For each directory: register command if run.sh exists
  - Command name = directory name
  - Validate run.sh is executable
  - Validate README.md exists and non-empty
- [ ] 8.6 Create command registration system
  - register_command(name, script_path) function
  - Store commands in associative array
  - Lookup command by name when executing
  - Route execution to correct plugin script
- [ ] 8.7 Implement JSON payload construction for plugin commands
  - Gather core configuration (project, database, etc.)
  - Add plugin-specific configuration (from defaults)
  - Merge user overrides (.env.dcx)
  - Build complete JSON object
  - Validate against command input schema
- [ ] 8.8 Implement plugin compose file loading
  - Load base compose files first
  - Then load mode-specific compose (default/mutagen/ssh)
  - Then load core service compose files
  - Finally load plugin service compose files from services/
- [ ] 8.9 Implement command README.md validation
  - Check for required sections: When Called, Available Variables, Expected Behavior, Usage Examples
  - Warn if sections missing
  - Generate command help from README.md
- [ ] 8.10 Test plugin structure validation
  - Test missing run.sh error
  - Test missing README.md warning
  - Test invalid directory structure
- [ ] 8.11 Test plugin isolation (core works without plugins)
- [ ] 8.12 Test plugin loading and unloading
- [ ] 8.13 Test command execution with JSON I/O
  - Verify JSON passed to stdin correctly
  - Verify stdout contains valid JSON result
  - Verify stderr contains logs only
  - Verify exit codes match JSON exit_code field
- [ ] 8.14 Test JSON payload construction
  - Verify core config included (project, database)
  - Verify plugin defaults merged
  - Verify user overrides from .env.dcx applied
  - Verify final JSON validates against schema
- [ ] 8.15 Document plugin structure convention
  - Create PLUGIN_DEVELOPMENT.md guide
  - Example plugin template
  - Fixed structure requirements
  - README.md template for commands
  - JSON Schema template
  - JSON communication protocol
- [ ] 8.16 Create example/template plugin
  - plugins/example/ with complete structure
  - Example command with JSON I/O
  - Example schemas
  - Comprehensive documentation
  - Can be copied for new plugins

## 9. Oro Plugin (Fixed Structure + JSON)
- [ ] 9.1 Create plugins/oro directory structure (FIXED convention)
  - plugins/oro/README.md (plugin overview)
  - plugins/oro/plugin.sh (detection and init)
  - plugins/oro/commands/ (command directories)
  - plugins/oro/services/ (Docker Compose services)
  - plugins/oro/schemas/ (JSON Schema files)
- [ ] 9.2 Create plugins/oro/plugin.sh
  - Implement plugin_detect() - check for oro/ packages in composer.json
  - Implement plugin_name() - return "oro"
  - Implement plugin_init() - auto-register commands from commands/ directory
  - Implement plugin_compose_files() - return service YAML files from services/
- [ ] 9.3 Create plugins/oro/env/defaults.sh (Oro environment variables)
  - DC_ORO_ADMIN_USER, DC_ORO_ADMIN_EMAIL, DC_ORO_ADMIN_PASSWORD
  - DC_ORO_ORG_NAME, DC_ORO_APP_URL
  - ORO_DB_URL, ORO_SEARCH_ENGINE_DSN, ORO_WEBSOCKET_*_DSN
  - All derived from core DC_* variables
- [ ] 9.4 Create Oro-specific Docker Compose services:
  - plugins/oro/services/websocket.yml
  - plugins/oro/services/consumer.yml
  - plugins/oro/services/elasticsearch.yml
- [ ] 9.5 Create JSON schemas for commands
  - plugins/oro/schemas/install-input.schema.json
  - plugins/oro/schemas/install-output.schema.json
  - plugins/oro/schemas/platformupdate-input.schema.json
  - plugins/oro/schemas/platformupdate-output.schema.json
  - plugins/oro/schemas/updateurl-input.schema.json
  - plugins/oro/schemas/updateurl-output.schema.json
  - plugins/oro/schemas/tests-input.schema.json
  - plugins/oro/schemas/tests-output.schema.json
- [ ] 9.6 Create command: install (with hybrid JSON)
  - plugins/oro/commands/install/run.sh (installation script with JSON)
    - Read context from DCX_CONTEXT environment (dcx version, paths, state)
    - Read JSON from stdin (project, database, oro config)
    - Validate stdin input against install-input.schema.json
    - Log both context and input to stderr
    - Return success/error JSON to stdout
  - plugins/oro/commands/install/README.md (JSON documentation)
    - When Called: dcx install, after dcx up -d
    - Context Schema: DCX_CONTEXT with dcx info, paths, state
    - Input Schema: JSON stdin with project, database, oro fields
    - Output Schema: success/error result with installation details
    - Expected Behavior: composer install + oro:install
    - Logging: Context and input to stderr
    - Usage Examples: pipe JSON, fixtures, jq parsing
    - Error Handling: error JSON format
- [ ] 9.7 Create command: platformupdate (with hybrid JSON)
  - plugins/oro/commands/platformupdate/run.sh (update script with JSON)
  - plugins/oro/commands/platformupdate/README.md (JSON documentation)
    - When Called: dcx platformupdate, after database import
    - Context Schema: DCX_CONTEXT (available but optional)
    - Input Schema: JSON stdin with project, options (skip-assets, force)
    - Output Schema: success/error with update details
    - Expected Behavior: oro:platform:update
    - Usage Examples: pipe JSON, with options, result parsing
- [ ] 9.8 Create command: updateurl (with hybrid JSON)
  - plugins/oro/commands/updateurl/run.sh (URL update script with JSON)
  - plugins/oro/commands/updateurl/README.md (JSON documentation)
    - When Called: dcx updateurl, after environment change
    - Context Schema: DCX_CONTEXT with paths
    - Input Schema: JSON stdin with urls.base, urls.secure
    - Output Schema: success/error with updated URLs
    - Expected Behavior: Update oro_config_value URLs via SQL
    - Usage Examples: pipe JSON, custom domain
- [ ] 9.9 Create command: tests (with hybrid JSON)
  - plugins/oro/commands/tests/run.sh (test environment script with JSON)
  - plugins/oro/commands/tests/README.md (JSON documentation)
    - When Called: dcx tests [command]
    - Context Schema: DCX_CONTEXT with test environment info
    - Input Schema: JSON stdin with test.command, test.args, test.env
    - Output Schema: success/error with test results
    - Expected Behavior: Isolated test environment execution
    - Usage Examples: pipe JSON, phpunit, behat
- [ ] 9.10 Create plugins/oro/README.md (plugin documentation)
  - Plugin Overview: Oro Platform/Commerce/CRM support
  - Detection Logic: oro/ packages in composer.json
  - Commands: List all commands with links to README
  - Services: WebSocket, consumer, Elasticsearch
  - JSON Schemas: Reference to schemas/ directory
  - Communication Protocol: JSON stdin/stdout, stderr logging
- [ ] 9.11 Test hybrid JSON communication for each command
  - Test install with DCX_CONTEXT + stdin JSON
  - Test install without DCX_CONTEXT (uses defaults)
  - Test install with invalid stdin JSON (schema validation error)
  - Test platformupdate with options
  - Test updateurl with custom URLs
  - Test tests command with different test suites
  - Test context fields are accessible in commands
- [ ] 9.12 Test command auto-registration
  - Verify all commands/ subdirectories are discovered
  - Verify run.sh validation (exists + executable)
  - Verify README.md validation (exists + non-empty)
  - Verify JSON Schema files exist (input + output)
- [ ] 9.13 Test JSON Schema validation
  - Test valid JSON passes schema validation
  - Test invalid JSON fails schema validation
  - Test missing required fields detected
  - Test type mismatches detected
  - Test enum validation works
- [ ] 9.14 Test stderr logging
  - Verify input JSON logged to stderr
  - Verify execution steps logged
  - Verify command outputs captured
  - Verify stderr doesn't interfere with stdout JSON
- [ ] 9.15 Test Oro plugin with OroCommerce 6.1
- [ ] 9.16 Test Oro plugin with OroPlatform 6.1
- [ ] 9.17 Test Oro plugin with OroCRM 6.1
- [ ] 9.18 Verify core works WITHOUT Oro plugin loaded
- [ ] 9.19 Write bats tests for Oro commands with JSON fixtures
  - Create fixtures/ directory with sample JSON inputs
  - Test each command with fixtures
  - Validate output JSON structure
  - Test error conditions
- [ ] 9.20 Document plugin structure for future framework adapters
  - JSON communication protocol
  - Schema file conventions
  - Logging best practices
  - Testing approach

## 10. Core Functionality (No Plugin Required)
- [ ] 10.1 Verify core works standalone (no plugins)
- [ ] 10.2 Test basic commands:
  - dcx up -d
  - dcx down
  - dcx ps
  - dcx logs
- [ ] 10.3 Test database operations:
  - dcx importdb dump.sql
  - dcx exportdb
  - dcx psql / mysql
- [ ] 10.4 Test PHP commands:
  - dcx php -v
  - dcx composer install
  - dcx ssh
  - dcx cli bash
- [ ] 10.5 Test with plain Symfony projects (no plugin)
- [ ] 10.6 Test with plain Laravel projects (no plugin)
- [ ] 10.7 Document "core only" usage

## 11. Main Entry Point
- [ ] 11.1 Create bin/dcx main entry point
- [ ] 11.2 Implement module loading system
- [ ] 11.3 Add module initialization order
- [ ] 11.4 Implement framework adapter bootstrapping
- [ ] 11.5 Add version and help commands
- [ ] 11.6 Test complete execution flow

## 12. Configuration Management
- [ ] 12.1 Implement .env.dcx file loading
- [ ] 12.2 Add configuration directory management (~/.dcx/)
- [ ] 12.3 Support DC_CONFIG_DIR environment variable override
- [ ] 12.4 Add configuration validation
- [ ] 12.5 Document configuration best practices
- [ ] 12.6 Test configuration loading in various scenarios

## 13. Compose Files - Base and Modes
- [ ] 13.1 Create compose/base.yml (networks and volumes only):
  - dc_shared_net network
  - appcode volume
  - home-user volume
  - home-root volume
- [ ] 13.2 Create compose/modes/default.yml (direct volume mount)
- [ ] 13.3 Create compose/modes/mutagen.yml (Mutagen sync for macOS)
- [ ] 13.4 Create compose/modes/ssh.yml (SSH remote sync)
- [ ] 13.5 Test each mode independently
- [ ] 13.6 Document when to use each mode

## 14. Compose Files - Core Services (One Service Per File)
- [ ] 14.1 Create compose/services/php-fpm.yml:
  - PHP-FPM container
  - Generic PHP image (no Oro assumptions)
  - Health check
  - Resource limits
- [ ] 14.2 Create compose/services/php-cli.yml:
  - PHP CLI container
  - Same image as FPM
  - No command (sleep infinity or one-off runs)
- [ ] 14.3 Create compose/services/nginx.yml:
  - Generic nginx configuration
  - No framework-specific rules
  - Traefik labels
  - Depends on php-fpm
- [ ] 14.4 Create compose/services/database-pgsql.yml:
  - PostgreSQL 15+ container
  - Volume for data persistence
  - Health check
  - Environment variables from DC_DATABASE_*
- [ ] 14.5 Create compose/services/database-mysql.yml:
  - MySQL/MariaDB container
  - Volume for data persistence
  - Health check
  - Alternative to PostgreSQL
- [ ] 14.6 Create compose/services/redis.yml:
  - Redis 6.2+ container
  - Single database (plugins configure multiple)
  - Health check
- [ ] 14.7 Create compose/services/rabbitmq.yml:
  - RabbitMQ 3.9+ with management
  - Generic MQ configuration
  - Health check
  - Management UI port
- [ ] 14.8 Create compose/services/mail.yml:
  - MailHog for email testing
  - SMTP and web UI ports
  - Traefik labels
- [ ] 14.9 Create compose/services/ssh.yml:
  - SSH server container
  - Same image as CLI
  - Host key persistence
  - Port 2222

## 15. Test Individual Services
- [ ] 15.1 Test each service starts independently
- [ ] 15.2 Test service health checks
- [ ] 15.3 Test service dependencies
- [ ] 15.4 Test service networking
- [ ] 15.5 Test volume mounts for each service
- [ ] 15.6 Test resource limits
- [ ] 15.7 Document service-specific configuration

## 16. Oro Plugin Compose Files
- [ ] 16.1 Create plugins/oro/compose/search.yml:
  - Elasticsearch 8.10.3
  - Oro-specific configuration
  - Volume for data
  - Health check
- [ ] 16.2 Create plugins/oro/compose/websocket.yml:
  - WebSocket server container
  - Oro websocket command
  - Traefik routing for /ws
- [ ] 16.3 Create plugins/oro/compose/consumer.yml:
  - Message consumer container
  - oro:message-queue:consume command
  - Auto-restart
- [ ] 16.4 Test Oro plugin services load correctly
- [ ] 16.5 Test Oro services DON'T load without plugin
- [ ] 16.6 Verify core works without Oro services

## 17. Docker Image Strategy
- [ ] 14.1 Design new image naming: ghcr.io/digitalspacestdio/dcx-*
- [ ] 14.2 Create framework-agnostic base images:
  - dcx-php:8.3-node20
  - dcx-php:8.4-node22
- [ ] 14.3 Create framework-specific images:
  - dcx-oro:8.3-node20 (Oro-optimized)
  - dcx-magento:8.3-node20 (future)
- [ ] 14.4 Set up automated image builds in CI/CD
- [ ] 14.5 Test image building and caching
- [ ] 14.6 Publish images to GitHub Container Registry

## 15. Documentation Updates
- [ ] 15.1 Update README.md for framework-agnostic usage
- [ ] 15.2 Create migration guide from orodc to dcx
- [ ] 15.3 Document module architecture
- [ ] 15.4 Create framework adapter development guide
- [ ] 15.5 Update AGENTS.md with new conventions
- [ ] 15.6 Add architecture diagrams
- [ ] 15.7 Create troubleshooting guide for modular architecture

## 18. Homebrew Formula Creation
- [ ] 16.1 Create NEW Formula/dcx.rb (separate from old orodc)
- [ ] 16.2 Configure dcx binary installation
- [ ] 16.3 Set up formula dependencies (docker, docker-compose, etc.)
- [ ] 16.4 Add module directory installation (dcx.d/, dcx-frameworks.d/)
- [ ] 16.5 Create comprehensive formula test suite
- [ ] 16.6 Test formula installation from scratch
- [ ] 16.7 Document formula in README
- [ ] 16.8 Keep old docker-compose-oroplatform formula for legacy support

## 19. CI/CD Updates
- [ ] 17.1 Update GitHub Actions workflows
- [ ] 17.2 Add modular testing strategy
- [ ] 17.3 Test framework adapter matrix
- [ ] 17.4 Add integration tests for all modules
- [ ] 17.5 Update Goss tests for new architecture
- [ ] 17.6 Verify CI/CD passes for all scenarios

## 20. Integration Testing
- [ ] 18.1 Test with Oro Platform 6.1 projects
- [ ] 18.2 Test with OroCommerce 6.1 projects
- [ ] 18.3 Test with OroCRM projects
- [ ] 18.4 Test with generic Symfony 6.x/7.x projects
- [ ] 18.5 Test with Laravel projects (generic adapter)
- [ ] 18.6 Test all infrastructure services (database, Redis, Elasticsearch, RabbitMQ)
- [ ] 18.7 Test all special commands (install, purge, tests, ssh, etc.)
- [ ] 18.8 Performance testing vs legacy OroDC
- [ ] 18.9 Load testing with multiple projects

## 21. Performance Optimization
- [ ] 19.1 Profile module loading time
- [ ] 19.2 Optimize critical path functions
- [ ] 19.3 Implement lazy loading if needed
- [ ] 19.4 Benchmark against monolithic version
- [ ] 19.5 Ensure <100ms overhead target met

## 22. Release Preparation (v1.0.0)
- [ ] 20.1 Complete all documentation rewrite
- [ ] 20.2 Create comprehensive CHANGELOG.md
- [ ] 20.3 Write migration guide from OroDC v0.x to WebStack v1.0
- [ ] 20.4 Create release notes highlighting new features
- [ ] 20.5 Set up GitHub Releases page
- [ ] 20.6 Prepare announcement blog post/documentation
- [ ] 20.7 Beta testing period (2-4 weeks)
- [ ] 20.8 Address beta feedback
- [ ] 20.9 Tag v1.0.0 release
- [ ] 20.10 Publish Homebrew formula
- [ ] 20.11 Announce release to community

## 23. Post-v1.0 Roadmap
- [ ] 21.1 Magento 2 framework adapter (v1.1)
- [ ] 21.2 Laravel framework adapter (v1.2)
- [ ] 21.3 WordPress framework adapter (v1.3)
- [ ] 21.4 Drupal framework adapter (v1.4)
- [ ] 21.5 Plugin development guide and SDK
- [ ] 21.6 Plugin marketplace/registry (v2.0)
- [ ] 21.7 Web UI for project management (v2.0)
- [ ] 21.8 Cloud deployment integrations (v2.1)

